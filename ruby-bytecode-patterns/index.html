<!doctype html><html lang><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title></title>
<meta name=description content="A Website about software by Adam Hess"><meta name=author content='Adam Hess'><link href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@400;700&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/bootstrap/4.6.2/css/bootstrap.min.css integrity="sha512-rt/SrQ4UNIaGfDyEXZtNcyWvQeOq0QLygHluFQcSjaGB04IxWhal71tKuzP6K8eYXYB6vJV4pHkXcmFGGQ1/0w==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.3/css/academicons.min.css integrity="sha512-vaoopdl+FJahyY2ddhsbDj8yDiRuyUYH/vIjF3z+cBg0sKc07NAQmUYli8volCGlW9OwlQyjVsr7Lh6qAManlw==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=/sass/researcher.min.css><link rel=icon type=image/ico href=https://www.hparker.xyz/favicon.ico></head><body><div class="container mt-5"><nav class="navbar navbar-expand-sm flex-column flex-sm-row text-nowrap p-0"><a class="navbar-brand mx-0 mr-sm-auto" href=https://www.hparker.xyz/ title=HParker>HParker</a><div class="navbar-nav flex-row flex-wrap justify-content-center"><a class="nav-item nav-link" href=/projects title="Projects & Games">Projects & Games
</a><span class="nav-item navbar-text mx-1">/</span>
<a class="nav-item nav-link" href=/resume.pdf title=Resume><svg width="1em" height="1em" viewBox="0 0 16 16" class="bi bi-file-earmark-person-fill" fill="currentcolor"><path fill-rule="evenodd" d="M2 2a2 2 0 012-2h5.293A1 1 0 0110 .293L13.707 4a1 1 0 01.293.707V14a2 2 0 01-2 2H4a2 2 0 01-2-2V2zm7.5 1.5v-2l3 3h-2a1 1 0 01-1-1zM11 8A3 3 0 115 8a3 3 0 016 0zm2 5.755S12 12 8 12s-5 1.755-5 1.755V14a1 1 0 001 1h8a1 1 0 001-1v-.245z"/></svg> Resume
</a><span class="nav-item navbar-text mx-1">/</span>
<a class="nav-item nav-link" href=/art title=Art>Art</a></div></nav></div><hr><div id=content><div class=container><h1 id=uncovering-ruby-bytecode-patterns>Uncovering Ruby Bytecode Patterns</h1><p><img src=/cute-stack-machine.jpg alt="Cute Stack Machine"></p><p>Since Ruby 1.9, Ruby runs your code in a bytecode VM. That means that the ruby compiler converts your code to a series of bytecode instructions. For example,</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>ruby --dump=insns -e &#39;5 * 10&#39;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>== disasm: #&lt;ISeq:&lt;main&gt;@-e:1 (1,0)-(1,6)&gt; (catch: false)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>0000 putobject                              5
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>0002 putobject                              10
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>0004 opt_mult                               &lt;calldata!mid:*, argc:1, ARGS_SIMPLE&gt;[CcCr]
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>0006 leave
</span></span></code></pre></div><p>The bytecode instructions <code>putobject</code> is called twice, <code>opt_mult</code> is called next, then lastly <code>leave</code>. These are the bytecode instructions that Ruby runs when executing <code>5 * 10</code>. Ruby uses a stack based VM, so after <code>putobject 5</code> is called, <code>5</code> is on the stack to be used by other instructions.</p><p><strong>What instructions the Ruby VM is actually running?</strong> Finding common patterns could lead to interesting optimizations and a better understanding of the Ruby VM. Ruby provides hooks for <code>dtrace</code>/<code>systemtap</code> to give this information. a DTrace probe can send us information every time an instruction is run in the VM.</p><h2 id=setup>Setup</h2><p>build Ruby with DTrace,</p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-bash data-lang=bash><span style=display:flex><span>git clone https://github.com/ruby/ruby.git
</span></span><span style=display:flex><span>./autogen.sh
</span></span><span style=display:flex><span>mkdir -p ~/.rubies
</span></span><span style=display:flex><span>./configure --prefix<span style=color:#666>=</span><span style=color:#b44>&#34;</span><span style=color:#b68;font-weight:700>${</span><span style=color:#b8860b>HOME</span><span style=color:#b68;font-weight:700>}</span><span style=color:#b44>/.rubies/ruby-master&#34;</span> --enable-dtrace
</span></span></code></pre></div><p>In <code>vm_opts.h</code> set <code>VM_COLLECT_USAGE_DETAILS</code> to 1</p><p>then,</p><pre tabindex=0><code>make install
</code></pre><p>Create this stp script somewhere handy,</p><pre tabindex=0><code>// ruby-instructions.stp
probe process(&#34;/path/to/ruby/bin/ruby&#34;).mark(&#34;insn&#34;)
{
    printf(&#34;%s\n&#34;, user_string($arg1))
}
</code></pre><p>Setup rails bench benchmark from <a href=https://github.com/k0kubun/railsbench>https://github.com/k0kubun/railsbench</a></p><p>Make sure to run single threaded and copy the pid from the web worker for the next step.</p><p>Capture with,</p><pre tabindex=0><code>bundle exec puma -e production --threads=1
sudo stap ruby-instructions.stp -o rails-bench.txt -x &lt;web worker pid&gt;
ab -c 1 -n 10000 localhost:3000/posts
</code></pre><p>You should now have a text file that is a long list of instructions Ruby ran during your test.</p><p><a href=https://gist.github.com/HParker/65c9ada9614301526a182b58be4f86fd>Full Parsed Results</a></p><h2 id=what-instructions-are-most-common>What instructions are most common?</h2><p><img src=/instruction-chart.png alt="Instruction Chart"></p><ul><li>getlocal_WC_0 = 1,903,656</li><li>opt_send_without_block = 1,638,356</li><li>leave = 1,057,370</li><li>putself = 729,499</li><li>branchunless = 626,085</li><li>putobject = 584,513</li><li>setlocal_WC_0 = 502,096</li><li>getinstancevariable = 434,992</li><li>pop = 407,503</li><li>dup = 375,151</li></ul><p>It seems <code>getlocal_WC_0</code>, <code>opt_send_without_block</code>, <code>leave</code> and <code>putself</code> are the most common instructions run in rails benchmark.</p><h2 id=what-instruction-pairs-are-common>What instruction pairs are common?</h2><p>After an instruction ran, what instructions are most likely to follow it? Because we are measuring a running program, these instructions are not necessarily generated next to each other, but instead they must be executed one after another.</p><h3 id=getlocal_wc_0>getlocal_WC_0</h3><p><img src=/getlocal_WC_0-chart.png alt=getlocal_WC_0-chart></p><p><code>getlocal_WC_0</code> is very often followed by <code>opt_send_without_block</code> or <code>getlocal_WC_0</code> calling itself again. Often running this instruction twice could mean that local access for multiple variables being as fast as possible could show good results in Rails bench.</p><h3 id=opt_send_without_block>opt_send_without_block</h3><p><img src=/opt_send_without_block-chart.png alt=opt_send_without_block-chart></p><h3 id=leave>leave</h3><p><img src=/leave-chart.png alt=leave-chart></p><p>The pattern <code>leave</code> -> <code>leave</code> is interesting. It is possible Ruby generates bytecode where <code>leave</code> is always called twice in a row. Unfortunately, it might be very uncommon that Ruby can know that two <code>leave</code> instructions are always called one after another. I am curious if Ruby could identify these situations.</p><h3 id=putself>putself</h3><p><img src=/putself-chart.png alt=putself-chart></p><p>This pattern seems like a, &ldquo;get ready for <code>opt_send_without_block</code>&rdquo; pattern that <code>putself</code> and <code>getlocal</code> are both a part of.</p><h3 id=branchunless>branchunless</h3><p><img src=/branchunless-chart.png alt=branchunless-chart></p><h3 id=putobject>putobject</h3><p><img src=/putobject-chart.png alt=putobject-chart></p><h3 id=setlocal_wc_0>setlocal_WC_0</h3><p><img src=/setlocal_wc_0-chart.png alt=setlocal_WC_0-chart></p><p>I am really curious how commonly these <code>setlocal</code> -> <code>getlocal</code> pattern is referencing the same variable. This could be replaced with <code>dup</code> -> <code>setlocal</code>, though that is only useful if these references are to the same variable. Alternatively, a &ldquo;stack preserving&rdquo; version of setlocal might be a different interesting alternative.</p><h3 id=getinstancevariable>getinstancevariable</h3><p><img src=/getinstancevariable-chart.png alt=getinstancevariable-chart></p><h3 id=pop>pop</h3><p><img src=/pop-chart.png alt=pop-chart></p><h3 id=dup>dup</h3><p><img src=/dup-chart.png alt=dup-chart></p><p>A common pattern starting with <code>dup</code> is, <code>["dup", "branchif", "pop"]</code>. This pattern ran 912,485 in our test. This instruction sequence gets generated from <code>x ||= 1</code>. <a href="http://www.rubyexplorer.xyz/explores?code=x+%7C%7C%3D+1&amp;coverage_enabled=true&amp;debug_frozen_string_literal=false&amp;frozen_string_literal=false&amp;inline_const_cache=true&amp;instructions_unification=false&amp;operands_unification=true&amp;peephole_optimization=true&amp;specialized_instruction=true&amp;stack_caching=false&amp;tailcall_optimization=false">rubyexplorer.xyz</a></p><div class=highlight><pre tabindex=0 style=background-color:#f8f8f8;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-text data-lang=text><span style=display:flex><span>== disasm: #&lt;ISeq:&lt;compiled&gt;@&lt;compiled&gt;:1 (1,0)-(1,7)&gt; (catch: FALSE)
</span></span><span style=display:flex><span>local table (size: 1, argc: 0 [opts: 0, rest: -1, post: 0, block: -1, kw: -1@-1, kwrest: -1])
</span></span><span style=display:flex><span>[ 1] x@0
</span></span><span style=display:flex><span>0000 getlocal_WC_0 x@0 ( 1)[Li]
</span></span><span style=display:flex><span>0002 dup
</span></span><span style=display:flex><span>0003 branchif 10
</span></span><span style=display:flex><span>0005 pop
</span></span><span style=display:flex><span>0006 putobject_INT2FIX_1_
</span></span><span style=display:flex><span>0007 dup
</span></span><span style=display:flex><span>0008 setlocal_WC_0 x@0
</span></span><span style=display:flex><span>0010 leave
</span></span></code></pre></div><p>This instruction sequence duplicates the top element on the stack, branches if that element is truthy and then removes the element it duplicated from the stack. If we are going to remove the original element on the stack anyways, why duplicate it in the first place? Turns out the Ruby VM knows that this sequence is suboptimal and has the information to generate a better sequence. This is the change to generate that better sequence: <a href=https://github.com/ruby/ruby/pull/6414>ruby/ruby#6414</a>. This optimization only has any effect if Ruby knows that the result of the conditional assignment is unused. After this change, conditional assignment where the result is ignored is <em>1.72x faster</em>.</p><h3 id=objtostring>objtostring</h3><p><img src=/objtostring-chart.png alt=objtostring-chart></p><p><code>objtostring</code> is almost always followed by <code>anytostring</code>. These instructions are used nearly exclusively for string interpolation <a href="https://www.rubyexplorer.xyz/explores?code=%22%23%7B123%7D%22&amp;coverage_enabled=true&amp;debug_frozen_string_literal=false&amp;frozen_string_literal=false&amp;inline_const_cache=true&amp;instructions_unification=false&amp;operands_unification=true&amp;peephole_optimization=true&amp;specialized_instruction=true&amp;stack_caching=false&amp;tailcall_optimization=false">rubyexplorer.xyz</a>. There have been two interesting Ruby changes related to string interpolation <a href=https://github.com/ruby/ruby/pull/6334>ruby/ruby#6334</a> and <a href=https://github.com/ruby/ruby/pull/6335>ruby/ruby#6335</a></p><h4 id=ps>P.S.</h4><p>While writing this I rediscovered <a href=http://tenderlovemaking.com/2011/12/05/profiling-rails-startup-with-dtrace.html>Tenderlove&rsquo;s old post about introducing Dtrace</a>. A good read if you find the time.</p><p>Also, if you are interested in learning more about YARV and the Ruby VM. I recommend <a href=https://kddnewton.com/yarv/>this YARV reference</a> and <a href=https://nostarch.com/rum>Ruby Under a Microscope</a>.</p></div></div><div id=footer class=mb-5><hr><div class="container text-center"><a href=https://www.hparker.xyz title="By Adam Hess"><small>By Adam Hess</small></a></div></div></body></html>