<!doctype html><html lang><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><title></title>
<meta name=description content="A Website about software by Adam Hess"><meta name=author content='Adam Hess'><link href="https://fonts.googleapis.com/css2?family=Inconsolata:wght@400;700&display=swap" rel=stylesheet><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/bootstrap/4.6.2/css/bootstrap.min.css integrity="sha512-rt/SrQ4UNIaGfDyEXZtNcyWvQeOq0QLygHluFQcSjaGB04IxWhal71tKuzP6K8eYXYB6vJV4pHkXcmFGGQ1/0w==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css integrity="sha512-iecdLmaskl7CVkqkXNQ/ZH/XLlvWZOJyj7Yy7tcenmpD1ypASozpmT/E0iPtmFIB46ZmdtAc9eNBvH0H/ZpiBw==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.3/css/academicons.min.css integrity="sha512-vaoopdl+FJahyY2ddhsbDj8yDiRuyUYH/vIjF3z+cBg0sKc07NAQmUYli8volCGlW9OwlQyjVsr7Lh6qAManlw==" crossorigin=anonymous referrerpolicy=no-referrer><link rel=stylesheet href=/sass/researcher.min.css><link rel=icon type=image/ico href=https://www.hparker.xyz/favicon.ico></head><body><div class="container mt-5"><nav class="navbar navbar-expand-sm flex-column flex-sm-row text-nowrap p-0"><a class="navbar-brand mx-0 mr-sm-auto" href=https://www.hparker.xyz/ title=HParker>HParker</a><div class="navbar-nav flex-row flex-wrap justify-content-center"><a class="nav-item nav-link" href=/projects title="Projects & Games">Projects & Games
</a><span class="nav-item navbar-text mx-1">/</span>
<a class="nav-item nav-link" href=/resume.pdf title=Resume><svg width="1em" height="1em" viewBox="0 0 16 16" class="bi bi-file-earmark-person-fill" fill="currentcolor"><path fill-rule="evenodd" d="M2 2a2 2 0 012-2h5.293A1 1 0 0110 .293L13.707 4a1 1 0 01.293.707V14a2 2 0 01-2 2H4a2 2 0 01-2-2V2zm7.5 1.5v-2l3 3h-2a1 1 0 01-1-1zM11 8A3 3 0 115 8a3 3 0 016 0zm2 5.755S12 12 8 12s-5 1.755-5 1.755V14a1 1 0 001 1h8a1 1 0 001-1v-.245z"/></svg> Resume
</a><span class="nav-item navbar-text mx-1">/</span>
<a class="nav-item nav-link" href=/art title=Art>Art</a></div></nav></div><hr><div id=content><div class=container><h1 id=regular-expressions-and-onigmo-the-ruby-regular-expression-engine>Regular Expressions and Onigmo, the Ruby regular expression engine</h1><p><img src=/regex-magic.jpg alt=regex-magic></p><p>Regular expressions (regex), are powerful tools for finding and manipulating patterns in text. They are widely used in programming languages and text editors, though they are often treated as a black box. I always considered them one part programming and one part magic. The internet is full of articles about how regex are used, but very few diving deeply into their implementations. Today we will explore the theory behind regular expressions, including a brief tour of the most basic theory. We will also delve into the implementation of the Onigmo regular expression engine, which is used in the Ruby programming language.</p><h1 id=brief-theory>Brief Theory</h1><p>I learned some of the theory behind regular expressions reading <a href=https://www.amazon.com/Engineering-Compiler-Keith-Cooper/dp/012088478X>&ldquo;Engineering a Compiler&rdquo; (Cooper & Torczon)</a>.</p><p>Regular expressions are a type of <a href=https://en.wikipedia.org/wiki/Finite-state_machine#Acceptors>recognizer</a>. Recognizer is a type of Finite State Automata (FA) which focuses on either accepting or rejecting a state. Here are the parts that makeup FA.</p><ul><li>Set of states</li><li>Set of characters in the automation&rsquo;s alphabet</li><li>Set of directed edges between those states</li><li>Start State</li><li>Set of acceptance states (which can also be the start state)</li></ul><p>The easiest way to understand and visualize the parts of a Finite State Machine is as a directed graph. <a href=https://graphviz.org/doc/info/lang.html>dot by graphviz</a> provides a nice way to generate these graphs.</p><p>We can create a recognizer for the word &ldquo;color&rdquo; that looks like this:</p><p><img src=/color-recognizer.png alt=color-recognizer></p><p>The recognizer starts at state 0 and is only ever in one state at a time. The recognizer moves through transitions when the next character matches the character above that arrow. This is called a state transition and is how FA do computation.</p><p>Later we could modify this state machine to accommodate alternative spellings like &ldquo;colour&rdquo;. The regular expression for this would be <code>/colou?r/</code>.</p><p><img src=/colour.png alt=colour></p><p>In the process we introduced a transition on Îµ (epsilon), a special character which is always accepted. Think of it like a &ldquo;free move&rdquo; in a board game. That means that on State 4 you can go to either state 5 or 7. This is the non-deterministic part of this Finite Automata (NFA). The recognizer needs to try one, see if it matches then try the other if it failed.</p><p>This kind of NFA pattern is common in regular expression which allow <a href=https://users.cs.cf.ac.uk/dave/PERL/node80.html>backtracking</a>. Backtracking allows regular expression to do powerful things and were popularized by Pearl&rsquo;s very powerful regular expression engine.</p><p><img src=/hopcroft.jpg alt=hopcroft></p><p>There are methods to convert NFAs into Deterministic Finite State Machines (DFA), however that is beyond the scope of this article. You can see a Ruby implementation of Hopcroft FA minimization <a href=https://github.com/HParker/redos-detector/blob/c2a79e4c1c530e63264379bceaedfa671947500b/lib/redos/detector/dfa.rb#L17>here</a> or learn more from the <a href=https://en.wikipedia.org/wiki/Finite-state_machine>wikipedia for FA</a>.</p><h1 id=onigmo>Onigmo</h1><p>Onigmo is a regular expression engine forked from <a href=https://github.com/kkos/oniguruma>Oniguruma</a> that is used in the Ruby programming language. It is a powerful engine that supports a wide range of regular expression features.</p><p><strong>What makes Onigmo work?</strong> Turns out Onigmo is a bytecode compiler similar to the Ruby VM itself. It parses the string into a series of tokens. Those tokens are consumed by the parser to create an Abstract Syntax Tree (AST) which is then converted into bytecode.</p><h2 id=parsing>Parsing</h2><p>The regular expression string is converted into a series of one of <a href=https://gist.github.com/HParker/1767b7a525ac7cc594a36c41062d7639#file-tokens-md>27 token types</a>. These tokens are used by the parser to build an AST using one of the <a href=https://gist.github.com/HParker/1767b7a525ac7cc594a36c41062d7639#file-nodes-md>11 node types</a>.</p><p>The example regex <code>ab?c</code> goes through the following steps,</p><p><img src=/abc-regex.jpg alt=abc-regex></p><p>Onigmo takes these tokens and builds an AST to use when generating bytecode. This takes the linear list of tokens and gives them the appropriate hierarchical relationship.</p><p>Interestingly, despite all the theory, there is no explicit NFA or DFA structure before Onigmo starts code generation.</p><h2 id=compiling>Compiling</h2><p>There are 97 bytecode operations. Out of those, here are <a href=https://gist.github.com/HParker/1767b7a525ac7cc594a36c41062d7639#file-ops-md>30 opcodes</a> that are enough to get an idea of what common instruction structures look like.</p><p>Bytecode for a regex like <code>/^ab?c(xyz)*$/</code> is,</p><pre tabindex=0><code>2A 02 61 3E 02 00 00 00
02 62 02 63 3E 0F 00 00
00 36 01 00 04 78 79 7A
39 01 00 3D EC FF FF FF
2B 01
</code></pre><p>And here it is with annotations showing which bytes are associated with which instructions.</p><p><img src=/bytecode-instructions.jpg alt=bytecode-instructions></p><p>All the instructions take the form of <code>OP_CODE + ARGUMENTS</code>. For example, in the regex above, the first byte, <code>0x2A</code> is the byte representing the opcode for <code>begin-line</code>. <code>begin-line</code> takes no arguments. The next byte, <code>0x02</code> represents <code>exact1</code> meaning &ldquo;match exactly this one character&rdquo;. The byte after that (the third byte) is the ascii value for the <code>a</code> character (61), which is the character <code>exact1</code> will match. The instruction takes up a different amount of space in the bytecode based on what arguments it takes.</p><pre tabindex=0><code>0:[begin-line]
1:[exact1:a]
3:[push:(+2)]
8:[exact1:b]
10:[exact1:c]
12:[push:(+15)]
17:[mem-start-push:1]
20:[exact3:xyz]
24:[mem-end:1]
27:[jump:(-20)]
32:[end-line]
33:[end]
</code></pre><p><img src=/bytecode-graph.jpg alt=bytecode-graph></p><p>Here is the NFA our theory books were talking about. Implicit in the bytecode jump and push instructions, the edges on our NFA are <code>jump</code> instructions and the <code>push</code> instructions are the paths followed when backtracking.</p><p>The graph shape is implicit in the bytecode that Onigmo generates. I was expecting an explicit &ldquo;build the NFA&rdquo; step in the compilation process, but in reality the graph structure we think about when treating regular expressions as Finite state automata (FA) is not valuable to tell the computer how to run a regular expression. Instead the bytecode encodes what steps the computer takes exactly as it should take them. The FA structure is a feature that the human reading understands about the system, but not an explicit construct.</p><h2 id=character-classes>Character classes</h2><p>Character classes represent a set of characters that can match with a particular set of characters. To do this match Onigmo builds a byteset. Each
bit represents a character&rsquo;s presence or absence from the set.</p><p><img src=/bitset-cropped.jpg alt=bitset-cropped></p><p>This does some math on the character&rsquo;s code to find its location in the bitset. Dividing the character code by 8, decides which byte to store the bit in. Then the specific bit is determined from the remainder of that division. Only one bit is used per character in the character class. Character classes also allow Onigmo to quickly check if a character is in the character class. Checking the bit is enabled is 2 math operations and a bit wise <code>&</code>.</p><p>The bytecode generated for the regex, <code>/[A-Za-z0-9]/</code> with a character class looks like,</p><pre tabindex=0><code>10 00 00 00 00 00 00 FF
03 FE FF FF 07 FE FF FF
07 00 00 00 00 00 00 00
00 00 00 00 00 00 00 00
00 01
</code></pre><p><code>0x10</code> is the op code for a character class. The next 32 bytes represent the character class. This is followed by <code>0x01</code> which is the <code>OP_END</code> instruction. When the character class is small, there are a lot of zero bytes. The more characters included in the character class, the more filled in bytes. However, the overall byte length is similar for all ascii matches.</p><h2 id=captures>Captures</h2><p>There are some additional opcodes used for capture data.</p><table><thead><tr><th>Op Code</th><th>Arguments</th><th>Usage</th></tr></thead><tbody><tr><td>OP_MEMORY_START_PUSH</td><td>2 byte memory location</td><td>Used when capturing a repeating pattern. Example: <code>/(abc)+/</code></td></tr><tr><td>OP_MEMORY_START</td><td>2 byte memory location</td><td>Used when capturing a pattern once. Example: <code>/(abc)/</code></td></tr><tr><td>OP_MEMORY_END_PUSH</td><td>2 byte memory location</td><td></td></tr><tr><td>OP_MEMORY_END</td><td>2 byte memory location</td><td></td></tr></tbody></table><p><em>There is a <code>REC</code> variant of the memory operations that is used in subexpression call operations, we are going to skip these instructions.</em></p><p>If the group is a capture, it is wrapped in a memory <code>start</code> and <code>end</code> operation. Memory start operation saves the location in the source string where the attempted match starts. The end is stored once the memory end instruction is reached. Invalid matches have -1 as the end location indicating that the match failed.</p><h1 id=what-we-know-now>What we know now</h1><p>Regular expressions work a bit more like a programming language virtual machine than I expected. There are a number of very specific tools Onigmo uses to improve performance, but the concepts are very usefully similar to compilers for other languages. By understanding the theory behind finite state machines and the implementation of regular expression engines like Onigmo, we can use this knowledge to improve our use of regular expressions and inform the design of other text processing tools.</p><h1 id=glossary-of-terms>Glossary of Terms</h1><p>If you go on to read the code, here are some terms that might be useful.</p><table><thead><tr><th>Term</th><th>Definition</th></tr></thead><tbody><tr><td>AST</td><td>Abstract Syntax Tree</td></tr><tr><td>CC</td><td>character class</td></tr><tr><td>DFA</td><td>Deterministic fininte state automata. Meaning each state has only one correct transition on a specific input</td></tr><tr><td>MB</td><td>multibyte</td></tr><tr><td>ML</td><td>multiline</td></tr><tr><td>IC</td><td>Ignore Case</td></tr><tr><td>NG</td><td>Not Greedy</td></tr><tr><td>NFA</td><td>Nondeterministic finite state automata. Meaning a state can have multiple edge options.</td></tr><tr><td>Quantifier</td><td>number of something</td></tr></tbody></table></div></div><div id=footer class=mb-5><hr><div class="container text-center"><a href=https://www.hparker.xyz title="By Adam Hess"><small>By Adam Hess</small></a></div></div></body></html>